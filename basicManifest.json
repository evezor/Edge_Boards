{
  "b3": [
    {
      "CAN_Token": 1,
      "RW": "W",
      "name": "reset",
      "value": null,
      "type": "function",
      "function": "reset()",
      "argument": "any",
      "comment": "Reset board."
    },
    {
      "CAN_Token": 2,
      "RW": "W",
      "name": "ping",
      "value": null,
      "type": "function",
      "function": "ping()",
      "argument": "any",
      "comment": "Device will ping back on same arbitration ID with timeStamp."
    },
    {
      "CAN_Token": 3,
      "RW": "RW",
      "name": "device_state",
      "value": 2,
      "type": "function",
      "function": "device_state()",
      "argument": "0-4",
      "comment": "0 = startup, 1 = sleep, 2 = standby, 3 = active, 4 = error."
    },
    {
      "CAN_Token": 4,
      "RW": "R",
      "name": "GUID",
      "value": 12345678,
      "type": "ID",
      "comment": "Device GUID"
    },
    {
      "CAN_Token": 5,
      "RW": "R",
      "name": "driver_version",
      "value": "v0.123",
      "type": "parameter",
      "comment": "Current driver version (this is marked read only as a new driver verion would imply a new manifest)  Also @Carl this particular field could check on boot that the manifest and the drivers are paired correctly. Any discrepency would throw a fault with appropriate error codes."
    },
    {
      "button1_Shitty_implementation": [
        {
          "CAN_Token": 6,
          "RW": "RW",
          "name": "button_name",
          "value": "button on D12",
          "type": "parameter",
          "argument": "string",
          "comment": "This is the colloquial name given to the button on D12."
        },
        {
          "CAN_Token": 7,
          "RW": "R",
          "name": "state",
          "value": 0,
          "type": "event",
          "return": "bool",
          "comment": "Current state of the button on Read. Event broadcast on !state, message contains value."
        },
        {
          "CAN_Token": 8,
          "RW": "RW",
          "name": "debounce",
          "value": 20,
          "type": "parameter",
          "argument": "0-1000",
          "comment": "Button debounce time. Argument taken as milliseconds."
        }
      ],
      "button2_CoolKids_Implemetation": [
        {
          "CAN_Token": 9,
          "RW": "RW",
          "name": "button_name",
          "value": "button on D11",
          "type": "parameter",
          "argument": "string",
          "comment": "This is the colloquial name given to the button on D12."
        },
        {
          "CAN_Token": 10,
          "RW": "R",
          "name": "state",
          "value": [
            {
              "onPress_counter": 1,
              "timeOut1_counter": 0,
              "timeOut2_counter": 1,
              "timeOut3_counter": 0,
              "onRelease_counter": 1
            }
          ],
          "type": "event",
          "return": "array[5] byte",
          "comment": "Current state of the button counters. If we're wanting onPress we've got it. If we're wanting a timout call we read that onRelease as the only other event that is passed is onRelease but in this case we also increment the counter for the correct timeout period.  In one case we can only know where we are based on where we've come from and in the other case we can tell whether the button is currently pressed because of the difference in the counters from onPress and onRelease. Additionally we can always know the state of a switch() tyope call as it's onRelease%2 unless there's some special cases for timeouts, but again those can be accounted for. In the example above, the button was pressed and released once, additionally the button was held down for a time between thresholds timeOut2 and timeOut3, thus triggering an event one timeOut2 for anyone listening. TimeOut3 is probably cancel_function and onRelease will be ignored?"
        },
        {
          "CAN_Token": 11,
          "RW": "RW",
          "name": "debounce",
          "value": 20,
          "type": "parameter",
          "argument": "0-1000",
          "comment": "Button debounce time. Argument taken as milliseconds."
        }
      ]
    },
    {
      "led_0_Shitty_implementation": [
        {
          "CAN_Token": 12,
          "RW": "RW",
          "name": "led_name",
          "value": "led on D12",
          "type": "parameter",
          "argument": "string",
          "comment": "This is the colloquial name given to the led on D13."
        },
        {
          "CAN_Token": 13,
          "RW": "RW",
          "name": "led_state",
          "value": 0,
          "type": "function",
          "function": "val()",
          "argument": "bool",
          "comment": "State of the led, may be read or written to."
        }
      ]
    },
    {
      "led_1_CoolKids_Implemetation": [
        {
          "CAN_Token": 14,
          "RW": "RW",
          "name": "led_name",
          "value": "led on D5",
          "type": "parameter",
          "argument": "string",
          "comment": "This is the colloquial name given to the led on D5."
        },
        {
          "CAN_Token": 15,
          "RW": "RW",
          "name": "led_state",
          "value": 0,
          "type": "function",
          "function": "val()",
          "argument": "bool",
          "comment": "State of the led, may be read or written to. on True function_name is called, on False function_name.deinit() is called"
        },
        {
          "CAN_Token": 16,
          "RW": "RW",
          "name": "led_duty",
          "value": 512,
          "type": "int",
          "argument": "0-1023",
          "comment": "led duty cycle. 0 is off and 1023 is 100% on"
        },
        {
          "CAN_Token": 17,
          "RW": "RW",
          "name": "led_freq",
          "value": 500,
          "type": "parameter",
          "argument": "0-1000",
          "comment": "frequency of PWM cycle on led. Argument taken as Hz"
        }
      ]
    },
    {
      "pot_0_Shitty_implementation": [
        {
          "CAN_Token": 18,
          "RW": "RW",
          "name": "pot_name",
          "value": "pot on A0",
          "type": "parameter",
          "argument": "string",
          "comment": "This is the colloquial name given to the pot on A0."
        },
        {
          "CAN_Token": 19,
          "RW": "R",
          "name": "pot_val",
          "value": 512,
          "type": "event",
          "argument": "12-bit",
          "comment": "most recent val captured by read function. Sent at interval pot_streamRate."
        },
        {
          "CAN_Token": 20,
          "RW": "RW",
          "name": "pot_active",
          "value": 1,
          "type": "parameter",
          "argument": "bool",
          "comment": "When this value is true it will begin the function that reads the pot at spits out [val] at [interval]"
        },
        {
          "CAN_Token": 21,
          "RW": "RW",
          "name": "pot_streamRate",
          "value": 1,
          "type": "parameter",
          "argument": "1-50",
          "comment": "the rate at which [pot_val] is sent. Value is represented in Hz"
        }
      ]
    },
    {
      "pot_nonExistent_CoolKids_Implemetation": [
        {
          "CAN_Token": 22,
          "RW": "RW",
          "name": "pot_name",
          "value": "pot on nonExistent",
          "type": "parameter",
          "argument": "string",
          "comment": "This is the colloquial name given to the pot on nonExistent."
        },
        {
          "CAN_Token": 23,
          "RW": "R",
          "name": "pot_val",
          "value": 512,
          "type": "parameter",
          "argument": "12-bit",
          "comment": "most recent val captured by read function. Note that this is a differnt type than the one given in pot_shitty implimentation.  in CoolKids implementation a single read value is never sent, only a polished value or set is ever released"
        },
        {
          "CAN_Token": 24,
          "RW": "RW",
          "name": "pot_active_state",
          "value": 2,
          "type": "parameter",
          "argument": "0-3",
          "comment": "0 = read[val] and sent @ [interval], 1 = average((read[val]*[sampleRate]/[streamRate])), 2 = event@[triggerVal], 3 = polynomial_function = numCoefficients@sampleRate processed and streamed @ streamRate."
        },
        {
          "CAN_Token": "25-27",
          "RW": "R",
          "name": "pot_event",
          "value": "defined in eventType",
          "type": "event",
          "return": "theEvent",
          "comment": "Threshold met to invoke event(). May be modified by triggerType for rising or falling edge. NOTE*** This entry takes multiple CAN_Tokens.  In the event that polynomials == 6 this will take 3 complete frames to transfer 6 32bit floats thus requiring more frames. val{1,2} in frame[25], val{3,4} in frame[26] and val{5,6} in frame[27]"
        },
        {
          "CAN_Token": 28,
          "RW": "RW",
          "name": "streamRate",
          "value": "2",
          "type": "parameter",
          "argument": "1-50",
          "comment": "Rate of event(). Units in Hz"
        },
        {
          "CAN_Token": 29,
          "RW": "RW",
          "name": "sampleRate",
          "value": "100",
          "type": "parameter",
          "argument": "1-1000000",
          "comment": "Rate at which to sample pot value. Units in Hz"
        },
        {
          "CAN_Token": 30,
          "RW": "RW",
          "name": "pot_trigger",
          "value": 512,
          "type": "parameter",
          "argument": "1-1023",
          "comment": "Threshold met to invoke event(). May be modified by triggerType for rising or falling edge"
        },
        {
          "CAN_Token": 31,
          "RW": "RW",
          "name": "pot_trigger_type",
          "value": "0",
          "type": "parameter",
          "argument": "0-3",
          "comment": "0 = rising edge, 1 = falling edge trigger, 2 = risingEdge+timeThreshold, 3 = fallingEdge+timeThreshold"
        }
      ]
    }
  ]
}
